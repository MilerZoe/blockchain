
# 创建账户体系代码解析

### 1.创建账户呢称

前台发起创建呢陈请求，接受页面输入的用户名，接受后台返回来的UUID，并将其存储在localStorage中

    <script>
      import moment from 'moment'
      import { Toast } from 'mint-ui'
      export default {
        data(){
          return {
            accountsName:'',
            accountNameBackMsg:''
          }
        },
        filters: {
          _formatTime(val) {
            return moment(val).fromNow();
          }
        },
        methods:{
          accountNameFun:function(){
            let accountsName = this.accountsName;
            if(!accountsName){
              Toast('请先输入用户名');
              return false;
            }
            localStorage.setItem("accounts-name", accountsName);
            this.startRequest();
          },
          onRequestBack() {
            let _this = this;
            this.$ipcRenderer.on('account-name-back', data => {
              _this.$ipcRenderer.detach('account-name-back');
              if(data && data.success) {
                _this.accountNameBackMsg = data.succMsg;
                localStorage.setItem("uuid", data.succMsg);
                if(_this.accountNameBackMsg == null){
                  Toast('后台报错，请重试或者联系Linkeye团队...');
                }else {
                  _this.toNextpage();
                }
              } else {
                if(data.errorCode == 100)
                {
                  Toast('您输入的用户名为空');
                }
              }
            })
          },
          startRequest() {
            this.$ipcRenderer.send('account-name', this.accountsName)
            this.onRequestBack();
          },
          toNextpage(){
            this.$router.push({path:'/account/password'})
          },
        }
      }
    </script>
    
    
node服务接到前台的请求，校验前台输入的数据是否为空，不为空，产生UUID，并将UUID返回给前台界面


        import CreateAccountName from '../ipc/ipcCreateAccountNameMsg'
        import executeQuerySql from "../sqlite/sqlite";
        const { shell } = require('electron');
        var UUID = require('uuid');

        const createAccountName = _createAccountNameIpc => ({
          ['account-name'](event, accountName) {
              const requestBack = data => {
                _createAccountNameIpc.sendToClient('account-name-back', data)
              };

            if(accountName != null) {
              console.log("get account name from front is " + accountName);
              requestBack({
                success: true,
                succMsg:UUID.v1()
              });
            }else {
              requestBack({
                success: false,
                error:"Have you already input you name",
                errorCode:100
              });
            }
          }
        });

        export default createAccountName

前接受界面的密码之后，发起生成keystore的接口请求

        <script>
          import moment from 'moment'
          import { Toast } from 'mint-ui'
            export default {
                data(){
                    return {
                passwd:'',
                passwdTwo:'',
                uuid:'',
                accountsName:'',
                privateKey:'',
                keystore:''
                    }
                },

            filters: {
              _formatTime(val) {
                return moment(val).fromNow();
              }
            },

                methods:{
              passwordFun:function(){
                let passwd = this.passwd;
                let passwdTwo = this.passwdTwo;
                if(!passwd){
                  Toast('密码为空，请输入密码');
                  return false;
                }
                if(!passwdTwo){
                  Toast('确认密码为空，请输入确认密码');
                  return false;
                }
                if(passwd.length <= 8){
                  Toast('密码长度不够，请慎重...');
                  return false;
                }
                if(passwd != passwdTwo){
                  Toast('两次输入的密码不一样,请重新输入');
                  return false;
                }
                this.startRequest();
              },

              onRequestBack() {
                let _this = this;
                this.$ipcRenderer.on('back-privateKey', data => {
                  _this.$ipcRenderer.detach('back-privateKey');
                  if(data && data.success) {
                    _this.privateKey = data.privateKey;
                    localStorage.setItem("address", data.privateKey.address);
                    localStorage.setItem("privateKey", data.privateKey.privateKey);
                    localStorage.setItem("keystore", data.privateKey.keystore);
                    localStorage.setItem("ciphertextPrivateKey", data.privateKey.ciphertextPrivateKey)
                    if(_this.privateKey == null){
                      Toast('后台报错，请重试联系或者Linkeye团队...');
                    }else {
                      _this.toNextpage();
                    }
                  } else {
                    if(data.errorCode == 201){
                      Toast('您输入的密码为空');
                    }
                    if(data.errorCode == 202) {
                      Toast('生成keystoress失败');
                    }
                  }
                })
              },

              startRequest() {
                localStorage.setItem("password", this.passwd);
                this.onRequestBack();
                this.$ipcRenderer.send('generate-keystore', this.passwd)
              },

                    toNextpage(){
                        this.$router.push({path:'/account/privateKey'})
                    }
                }
            }
        </script>

接收前台数据后，校验keystore目录是否存在，存在就生keystore，并将keystore导入到文件
